package requestexecutor

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/insolar/insolar"
	"github.com/insolar/insolar/insolar/record"
	"github.com/insolar/insolar/logicrunner/artifacts"
	"github.com/insolar/insolar/logicrunner/common"
)

// RequestExecutorMock implements RequestExecutor
type RequestExecutorMock struct {
	t minimock.Tester

	funcExecute          func(ctx context.Context, current *common.Transcript) (r1 artifacts.RequestResult, err error)
	inspectFuncExecute   func(ctx context.Context, current *common.Transcript)
	afterExecuteCounter  uint64
	beforeExecuteCounter uint64
	ExecuteMock          mRequestExecutorMockExecute

	funcExecuteAndSave          func(ctx context.Context, current *common.Transcript) (r1 artifacts.RequestResult, err error)
	inspectFuncExecuteAndSave   func(ctx context.Context, current *common.Transcript)
	afterExecuteAndSaveCounter  uint64
	beforeExecuteAndSaveCounter uint64
	ExecuteAndSaveMock          mRequestExecutorMockExecuteAndSave

	funcSave          func(ctx context.Context, current *common.Transcript, res artifacts.RequestResult) (err error)
	inspectFuncSave   func(ctx context.Context, current *common.Transcript, res artifacts.RequestResult)
	afterSaveCounter  uint64
	beforeSaveCounter uint64
	SaveMock          mRequestExecutorMockSave

	funcSendReply          func(ctx context.Context, reqRef insolar.Reference, req record.IncomingRequest, re insolar.Reply, err error)
	inspectFuncSendReply   func(ctx context.Context, reqRef insolar.Reference, req record.IncomingRequest, re insolar.Reply, err error)
	afterSendReplyCounter  uint64
	beforeSendReplyCounter uint64
	SendReplyMock          mRequestExecutorMockSendReply
}

// NewRequestExecutorMock returns a mock for RequestExecutor
func NewRequestExecutorMock(t minimock.Tester) *RequestExecutorMock {
	m := &RequestExecutorMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ExecuteMock = mRequestExecutorMockExecute{mock: m}
	m.ExecuteMock.callArgs = []*RequestExecutorMockExecuteParams{}

	m.ExecuteAndSaveMock = mRequestExecutorMockExecuteAndSave{mock: m}
	m.ExecuteAndSaveMock.callArgs = []*RequestExecutorMockExecuteAndSaveParams{}

	m.SaveMock = mRequestExecutorMockSave{mock: m}
	m.SaveMock.callArgs = []*RequestExecutorMockSaveParams{}

	m.SendReplyMock = mRequestExecutorMockSendReply{mock: m}
	m.SendReplyMock.callArgs = []*RequestExecutorMockSendReplyParams{}

	return m
}

type mRequestExecutorMockExecute struct {
	mock               *RequestExecutorMock
	defaultExpectation *RequestExecutorMockExecuteExpectation
	expectations       []*RequestExecutorMockExecuteExpectation

	callArgs []*RequestExecutorMockExecuteParams
	mutex    sync.RWMutex
}

// RequestExecutorMockExecuteExpectation specifies expectation struct of the RequestExecutor.Execute
type RequestExecutorMockExecuteExpectation struct {
	mock    *RequestExecutorMock
	params  *RequestExecutorMockExecuteParams
	results *RequestExecutorMockExecuteResults
	Counter uint64
}

// RequestExecutorMockExecuteParams contains parameters of the RequestExecutor.Execute
type RequestExecutorMockExecuteParams struct {
	ctx     context.Context
	current *common.Transcript
}

// RequestExecutorMockExecuteResults contains results of the RequestExecutor.Execute
type RequestExecutorMockExecuteResults struct {
	r1  artifacts.RequestResult
	err error
}

// Expect sets up expected params for RequestExecutor.Execute
func (mmExecute *mRequestExecutorMockExecute) Expect(ctx context.Context, current *common.Transcript) *mRequestExecutorMockExecute {
	if mmExecute.mock.funcExecute != nil {
		mmExecute.mock.t.Fatalf("RequestExecutorMock.Execute mock is already set by Set")
	}

	if mmExecute.defaultExpectation == nil {
		mmExecute.defaultExpectation = &RequestExecutorMockExecuteExpectation{}
	}

	mmExecute.defaultExpectation.params = &RequestExecutorMockExecuteParams{ctx, current}
	for _, e := range mmExecute.expectations {
		if minimock.Equal(e.params, mmExecute.defaultExpectation.params) {
			mmExecute.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExecute.defaultExpectation.params)
		}
	}

	return mmExecute
}

// Inspect accepts an inspector function that has same arguments as the RequestExecutor.Execute
func (mmExecute *mRequestExecutorMockExecute) Inspect(f func(ctx context.Context, current *common.Transcript)) *mRequestExecutorMockExecute {
	if mmExecute.mock.inspectFuncExecute != nil {
		mmExecute.mock.t.Fatalf("Inspect function is already set for RequestExecutorMock.Execute")
	}

	mmExecute.mock.inspectFuncExecute = f

	return mmExecute
}

// Return sets up results that will be returned by RequestExecutor.Execute
func (mmExecute *mRequestExecutorMockExecute) Return(r1 artifacts.RequestResult, err error) *RequestExecutorMock {
	if mmExecute.mock.funcExecute != nil {
		mmExecute.mock.t.Fatalf("RequestExecutorMock.Execute mock is already set by Set")
	}

	if mmExecute.defaultExpectation == nil {
		mmExecute.defaultExpectation = &RequestExecutorMockExecuteExpectation{mock: mmExecute.mock}
	}
	mmExecute.defaultExpectation.results = &RequestExecutorMockExecuteResults{r1, err}
	return mmExecute.mock
}

//Set uses given function f to mock the RequestExecutor.Execute method
func (mmExecute *mRequestExecutorMockExecute) Set(f func(ctx context.Context, current *common.Transcript) (r1 artifacts.RequestResult, err error)) *RequestExecutorMock {
	if mmExecute.defaultExpectation != nil {
		mmExecute.mock.t.Fatalf("Default expectation is already set for the RequestExecutor.Execute method")
	}

	if len(mmExecute.expectations) > 0 {
		mmExecute.mock.t.Fatalf("Some expectations are already set for the RequestExecutor.Execute method")
	}

	mmExecute.mock.funcExecute = f
	return mmExecute.mock
}

// When sets expectation for the RequestExecutor.Execute which will trigger the result defined by the following
// Then helper
func (mmExecute *mRequestExecutorMockExecute) When(ctx context.Context, current *common.Transcript) *RequestExecutorMockExecuteExpectation {
	if mmExecute.mock.funcExecute != nil {
		mmExecute.mock.t.Fatalf("RequestExecutorMock.Execute mock is already set by Set")
	}

	expectation := &RequestExecutorMockExecuteExpectation{
		mock:   mmExecute.mock,
		params: &RequestExecutorMockExecuteParams{ctx, current},
	}
	mmExecute.expectations = append(mmExecute.expectations, expectation)
	return expectation
}

// Then sets up RequestExecutor.Execute return parameters for the expectation previously defined by the When method
func (e *RequestExecutorMockExecuteExpectation) Then(r1 artifacts.RequestResult, err error) *RequestExecutorMock {
	e.results = &RequestExecutorMockExecuteResults{r1, err}
	return e.mock
}

// Execute implements RequestExecutor
func (mmExecute *RequestExecutorMock) Execute(ctx context.Context, current *common.Transcript) (r1 artifacts.RequestResult, err error) {
	mm_atomic.AddUint64(&mmExecute.beforeExecuteCounter, 1)
	defer mm_atomic.AddUint64(&mmExecute.afterExecuteCounter, 1)

	if mmExecute.inspectFuncExecute != nil {
		mmExecute.inspectFuncExecute(ctx, current)
	}

	mm_params := &RequestExecutorMockExecuteParams{ctx, current}

	// Record call args
	mmExecute.ExecuteMock.mutex.Lock()
	mmExecute.ExecuteMock.callArgs = append(mmExecute.ExecuteMock.callArgs, mm_params)
	mmExecute.ExecuteMock.mutex.Unlock()

	for _, e := range mmExecute.ExecuteMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmExecute.ExecuteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExecute.ExecuteMock.defaultExpectation.Counter, 1)
		mm_want := mmExecute.ExecuteMock.defaultExpectation.params
		mm_got := RequestExecutorMockExecuteParams{ctx, current}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmExecute.t.Errorf("RequestExecutorMock.Execute got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmExecute.ExecuteMock.defaultExpectation.results
		if mm_results == nil {
			mmExecute.t.Fatal("No results are set for the RequestExecutorMock.Execute")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmExecute.funcExecute != nil {
		return mmExecute.funcExecute(ctx, current)
	}
	mmExecute.t.Fatalf("Unexpected call to RequestExecutorMock.Execute. %v %v", ctx, current)
	return
}

// ExecuteAfterCounter returns a count of finished RequestExecutorMock.Execute invocations
func (mmExecute *RequestExecutorMock) ExecuteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExecute.afterExecuteCounter)
}

// ExecuteBeforeCounter returns a count of RequestExecutorMock.Execute invocations
func (mmExecute *RequestExecutorMock) ExecuteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExecute.beforeExecuteCounter)
}

// Calls returns a list of arguments used in each call to RequestExecutorMock.Execute.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExecute *mRequestExecutorMockExecute) Calls() []*RequestExecutorMockExecuteParams {
	mmExecute.mutex.RLock()

	argCopy := make([]*RequestExecutorMockExecuteParams, len(mmExecute.callArgs))
	copy(argCopy, mmExecute.callArgs)

	mmExecute.mutex.RUnlock()

	return argCopy
}

// MinimockExecuteDone returns true if the count of the Execute invocations corresponds
// the number of defined expectations
func (m *RequestExecutorMock) MinimockExecuteDone() bool {
	for _, e := range m.ExecuteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ExecuteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterExecuteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExecute != nil && mm_atomic.LoadUint64(&m.afterExecuteCounter) < 1 {
		return false
	}
	return true
}

// MinimockExecuteInspect logs each unmet expectation
func (m *RequestExecutorMock) MinimockExecuteInspect() {
	for _, e := range m.ExecuteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RequestExecutorMock.Execute with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ExecuteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterExecuteCounter) < 1 {
		if m.ExecuteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RequestExecutorMock.Execute")
		} else {
			m.t.Errorf("Expected call to RequestExecutorMock.Execute with params: %#v", *m.ExecuteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExecute != nil && mm_atomic.LoadUint64(&m.afterExecuteCounter) < 1 {
		m.t.Error("Expected call to RequestExecutorMock.Execute")
	}
}

type mRequestExecutorMockExecuteAndSave struct {
	mock               *RequestExecutorMock
	defaultExpectation *RequestExecutorMockExecuteAndSaveExpectation
	expectations       []*RequestExecutorMockExecuteAndSaveExpectation

	callArgs []*RequestExecutorMockExecuteAndSaveParams
	mutex    sync.RWMutex
}

// RequestExecutorMockExecuteAndSaveExpectation specifies expectation struct of the RequestExecutor.ExecuteAndSave
type RequestExecutorMockExecuteAndSaveExpectation struct {
	mock    *RequestExecutorMock
	params  *RequestExecutorMockExecuteAndSaveParams
	results *RequestExecutorMockExecuteAndSaveResults
	Counter uint64
}

// RequestExecutorMockExecuteAndSaveParams contains parameters of the RequestExecutor.ExecuteAndSave
type RequestExecutorMockExecuteAndSaveParams struct {
	ctx     context.Context
	current *common.Transcript
}

// RequestExecutorMockExecuteAndSaveResults contains results of the RequestExecutor.ExecuteAndSave
type RequestExecutorMockExecuteAndSaveResults struct {
	r1  artifacts.RequestResult
	err error
}

// Expect sets up expected params for RequestExecutor.ExecuteAndSave
func (mmExecuteAndSave *mRequestExecutorMockExecuteAndSave) Expect(ctx context.Context, current *common.Transcript) *mRequestExecutorMockExecuteAndSave {
	if mmExecuteAndSave.mock.funcExecuteAndSave != nil {
		mmExecuteAndSave.mock.t.Fatalf("RequestExecutorMock.ExecuteAndSave mock is already set by Set")
	}

	if mmExecuteAndSave.defaultExpectation == nil {
		mmExecuteAndSave.defaultExpectation = &RequestExecutorMockExecuteAndSaveExpectation{}
	}

	mmExecuteAndSave.defaultExpectation.params = &RequestExecutorMockExecuteAndSaveParams{ctx, current}
	for _, e := range mmExecuteAndSave.expectations {
		if minimock.Equal(e.params, mmExecuteAndSave.defaultExpectation.params) {
			mmExecuteAndSave.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExecuteAndSave.defaultExpectation.params)
		}
	}

	return mmExecuteAndSave
}

// Inspect accepts an inspector function that has same arguments as the RequestExecutor.ExecuteAndSave
func (mmExecuteAndSave *mRequestExecutorMockExecuteAndSave) Inspect(f func(ctx context.Context, current *common.Transcript)) *mRequestExecutorMockExecuteAndSave {
	if mmExecuteAndSave.mock.inspectFuncExecuteAndSave != nil {
		mmExecuteAndSave.mock.t.Fatalf("Inspect function is already set for RequestExecutorMock.ExecuteAndSave")
	}

	mmExecuteAndSave.mock.inspectFuncExecuteAndSave = f

	return mmExecuteAndSave
}

// Return sets up results that will be returned by RequestExecutor.ExecuteAndSave
func (mmExecuteAndSave *mRequestExecutorMockExecuteAndSave) Return(r1 artifacts.RequestResult, err error) *RequestExecutorMock {
	if mmExecuteAndSave.mock.funcExecuteAndSave != nil {
		mmExecuteAndSave.mock.t.Fatalf("RequestExecutorMock.ExecuteAndSave mock is already set by Set")
	}

	if mmExecuteAndSave.defaultExpectation == nil {
		mmExecuteAndSave.defaultExpectation = &RequestExecutorMockExecuteAndSaveExpectation{mock: mmExecuteAndSave.mock}
	}
	mmExecuteAndSave.defaultExpectation.results = &RequestExecutorMockExecuteAndSaveResults{r1, err}
	return mmExecuteAndSave.mock
}

//Set uses given function f to mock the RequestExecutor.ExecuteAndSave method
func (mmExecuteAndSave *mRequestExecutorMockExecuteAndSave) Set(f func(ctx context.Context, current *common.Transcript) (r1 artifacts.RequestResult, err error)) *RequestExecutorMock {
	if mmExecuteAndSave.defaultExpectation != nil {
		mmExecuteAndSave.mock.t.Fatalf("Default expectation is already set for the RequestExecutor.ExecuteAndSave method")
	}

	if len(mmExecuteAndSave.expectations) > 0 {
		mmExecuteAndSave.mock.t.Fatalf("Some expectations are already set for the RequestExecutor.ExecuteAndSave method")
	}

	mmExecuteAndSave.mock.funcExecuteAndSave = f
	return mmExecuteAndSave.mock
}

// When sets expectation for the RequestExecutor.ExecuteAndSave which will trigger the result defined by the following
// Then helper
func (mmExecuteAndSave *mRequestExecutorMockExecuteAndSave) When(ctx context.Context, current *common.Transcript) *RequestExecutorMockExecuteAndSaveExpectation {
	if mmExecuteAndSave.mock.funcExecuteAndSave != nil {
		mmExecuteAndSave.mock.t.Fatalf("RequestExecutorMock.ExecuteAndSave mock is already set by Set")
	}

	expectation := &RequestExecutorMockExecuteAndSaveExpectation{
		mock:   mmExecuteAndSave.mock,
		params: &RequestExecutorMockExecuteAndSaveParams{ctx, current},
	}
	mmExecuteAndSave.expectations = append(mmExecuteAndSave.expectations, expectation)
	return expectation
}

// Then sets up RequestExecutor.ExecuteAndSave return parameters for the expectation previously defined by the When method
func (e *RequestExecutorMockExecuteAndSaveExpectation) Then(r1 artifacts.RequestResult, err error) *RequestExecutorMock {
	e.results = &RequestExecutorMockExecuteAndSaveResults{r1, err}
	return e.mock
}

// ExecuteAndSave implements RequestExecutor
func (mmExecuteAndSave *RequestExecutorMock) ExecuteAndSave(ctx context.Context, current *common.Transcript) (r1 artifacts.RequestResult, err error) {
	mm_atomic.AddUint64(&mmExecuteAndSave.beforeExecuteAndSaveCounter, 1)
	defer mm_atomic.AddUint64(&mmExecuteAndSave.afterExecuteAndSaveCounter, 1)

	if mmExecuteAndSave.inspectFuncExecuteAndSave != nil {
		mmExecuteAndSave.inspectFuncExecuteAndSave(ctx, current)
	}

	mm_params := &RequestExecutorMockExecuteAndSaveParams{ctx, current}

	// Record call args
	mmExecuteAndSave.ExecuteAndSaveMock.mutex.Lock()
	mmExecuteAndSave.ExecuteAndSaveMock.callArgs = append(mmExecuteAndSave.ExecuteAndSaveMock.callArgs, mm_params)
	mmExecuteAndSave.ExecuteAndSaveMock.mutex.Unlock()

	for _, e := range mmExecuteAndSave.ExecuteAndSaveMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmExecuteAndSave.ExecuteAndSaveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExecuteAndSave.ExecuteAndSaveMock.defaultExpectation.Counter, 1)
		mm_want := mmExecuteAndSave.ExecuteAndSaveMock.defaultExpectation.params
		mm_got := RequestExecutorMockExecuteAndSaveParams{ctx, current}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmExecuteAndSave.t.Errorf("RequestExecutorMock.ExecuteAndSave got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmExecuteAndSave.ExecuteAndSaveMock.defaultExpectation.results
		if mm_results == nil {
			mmExecuteAndSave.t.Fatal("No results are set for the RequestExecutorMock.ExecuteAndSave")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmExecuteAndSave.funcExecuteAndSave != nil {
		return mmExecuteAndSave.funcExecuteAndSave(ctx, current)
	}
	mmExecuteAndSave.t.Fatalf("Unexpected call to RequestExecutorMock.ExecuteAndSave. %v %v", ctx, current)
	return
}

// ExecuteAndSaveAfterCounter returns a count of finished RequestExecutorMock.ExecuteAndSave invocations
func (mmExecuteAndSave *RequestExecutorMock) ExecuteAndSaveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExecuteAndSave.afterExecuteAndSaveCounter)
}

// ExecuteAndSaveBeforeCounter returns a count of RequestExecutorMock.ExecuteAndSave invocations
func (mmExecuteAndSave *RequestExecutorMock) ExecuteAndSaveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExecuteAndSave.beforeExecuteAndSaveCounter)
}

// Calls returns a list of arguments used in each call to RequestExecutorMock.ExecuteAndSave.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExecuteAndSave *mRequestExecutorMockExecuteAndSave) Calls() []*RequestExecutorMockExecuteAndSaveParams {
	mmExecuteAndSave.mutex.RLock()

	argCopy := make([]*RequestExecutorMockExecuteAndSaveParams, len(mmExecuteAndSave.callArgs))
	copy(argCopy, mmExecuteAndSave.callArgs)

	mmExecuteAndSave.mutex.RUnlock()

	return argCopy
}

// MinimockExecuteAndSaveDone returns true if the count of the ExecuteAndSave invocations corresponds
// the number of defined expectations
func (m *RequestExecutorMock) MinimockExecuteAndSaveDone() bool {
	for _, e := range m.ExecuteAndSaveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ExecuteAndSaveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterExecuteAndSaveCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExecuteAndSave != nil && mm_atomic.LoadUint64(&m.afterExecuteAndSaveCounter) < 1 {
		return false
	}
	return true
}

// MinimockExecuteAndSaveInspect logs each unmet expectation
func (m *RequestExecutorMock) MinimockExecuteAndSaveInspect() {
	for _, e := range m.ExecuteAndSaveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RequestExecutorMock.ExecuteAndSave with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ExecuteAndSaveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterExecuteAndSaveCounter) < 1 {
		if m.ExecuteAndSaveMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RequestExecutorMock.ExecuteAndSave")
		} else {
			m.t.Errorf("Expected call to RequestExecutorMock.ExecuteAndSave with params: %#v", *m.ExecuteAndSaveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExecuteAndSave != nil && mm_atomic.LoadUint64(&m.afterExecuteAndSaveCounter) < 1 {
		m.t.Error("Expected call to RequestExecutorMock.ExecuteAndSave")
	}
}

type mRequestExecutorMockSave struct {
	mock               *RequestExecutorMock
	defaultExpectation *RequestExecutorMockSaveExpectation
	expectations       []*RequestExecutorMockSaveExpectation

	callArgs []*RequestExecutorMockSaveParams
	mutex    sync.RWMutex
}

// RequestExecutorMockSaveExpectation specifies expectation struct of the RequestExecutor.Save
type RequestExecutorMockSaveExpectation struct {
	mock    *RequestExecutorMock
	params  *RequestExecutorMockSaveParams
	results *RequestExecutorMockSaveResults
	Counter uint64
}

// RequestExecutorMockSaveParams contains parameters of the RequestExecutor.Save
type RequestExecutorMockSaveParams struct {
	ctx     context.Context
	current *common.Transcript
	res     artifacts.RequestResult
}

// RequestExecutorMockSaveResults contains results of the RequestExecutor.Save
type RequestExecutorMockSaveResults struct {
	err error
}

// Expect sets up expected params for RequestExecutor.Save
func (mmSave *mRequestExecutorMockSave) Expect(ctx context.Context, current *common.Transcript, res artifacts.RequestResult) *mRequestExecutorMockSave {
	if mmSave.mock.funcSave != nil {
		mmSave.mock.t.Fatalf("RequestExecutorMock.Save mock is already set by Set")
	}

	if mmSave.defaultExpectation == nil {
		mmSave.defaultExpectation = &RequestExecutorMockSaveExpectation{}
	}

	mmSave.defaultExpectation.params = &RequestExecutorMockSaveParams{ctx, current, res}
	for _, e := range mmSave.expectations {
		if minimock.Equal(e.params, mmSave.defaultExpectation.params) {
			mmSave.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSave.defaultExpectation.params)
		}
	}

	return mmSave
}

// Inspect accepts an inspector function that has same arguments as the RequestExecutor.Save
func (mmSave *mRequestExecutorMockSave) Inspect(f func(ctx context.Context, current *common.Transcript, res artifacts.RequestResult)) *mRequestExecutorMockSave {
	if mmSave.mock.inspectFuncSave != nil {
		mmSave.mock.t.Fatalf("Inspect function is already set for RequestExecutorMock.Save")
	}

	mmSave.mock.inspectFuncSave = f

	return mmSave
}

// Return sets up results that will be returned by RequestExecutor.Save
func (mmSave *mRequestExecutorMockSave) Return(err error) *RequestExecutorMock {
	if mmSave.mock.funcSave != nil {
		mmSave.mock.t.Fatalf("RequestExecutorMock.Save mock is already set by Set")
	}

	if mmSave.defaultExpectation == nil {
		mmSave.defaultExpectation = &RequestExecutorMockSaveExpectation{mock: mmSave.mock}
	}
	mmSave.defaultExpectation.results = &RequestExecutorMockSaveResults{err}
	return mmSave.mock
}

//Set uses given function f to mock the RequestExecutor.Save method
func (mmSave *mRequestExecutorMockSave) Set(f func(ctx context.Context, current *common.Transcript, res artifacts.RequestResult) (err error)) *RequestExecutorMock {
	if mmSave.defaultExpectation != nil {
		mmSave.mock.t.Fatalf("Default expectation is already set for the RequestExecutor.Save method")
	}

	if len(mmSave.expectations) > 0 {
		mmSave.mock.t.Fatalf("Some expectations are already set for the RequestExecutor.Save method")
	}

	mmSave.mock.funcSave = f
	return mmSave.mock
}

// When sets expectation for the RequestExecutor.Save which will trigger the result defined by the following
// Then helper
func (mmSave *mRequestExecutorMockSave) When(ctx context.Context, current *common.Transcript, res artifacts.RequestResult) *RequestExecutorMockSaveExpectation {
	if mmSave.mock.funcSave != nil {
		mmSave.mock.t.Fatalf("RequestExecutorMock.Save mock is already set by Set")
	}

	expectation := &RequestExecutorMockSaveExpectation{
		mock:   mmSave.mock,
		params: &RequestExecutorMockSaveParams{ctx, current, res},
	}
	mmSave.expectations = append(mmSave.expectations, expectation)
	return expectation
}

// Then sets up RequestExecutor.Save return parameters for the expectation previously defined by the When method
func (e *RequestExecutorMockSaveExpectation) Then(err error) *RequestExecutorMock {
	e.results = &RequestExecutorMockSaveResults{err}
	return e.mock
}

// Save implements RequestExecutor
func (mmSave *RequestExecutorMock) Save(ctx context.Context, current *common.Transcript, res artifacts.RequestResult) (err error) {
	mm_atomic.AddUint64(&mmSave.beforeSaveCounter, 1)
	defer mm_atomic.AddUint64(&mmSave.afterSaveCounter, 1)

	if mmSave.inspectFuncSave != nil {
		mmSave.inspectFuncSave(ctx, current, res)
	}

	mm_params := &RequestExecutorMockSaveParams{ctx, current, res}

	// Record call args
	mmSave.SaveMock.mutex.Lock()
	mmSave.SaveMock.callArgs = append(mmSave.SaveMock.callArgs, mm_params)
	mmSave.SaveMock.mutex.Unlock()

	for _, e := range mmSave.SaveMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSave.SaveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSave.SaveMock.defaultExpectation.Counter, 1)
		mm_want := mmSave.SaveMock.defaultExpectation.params
		mm_got := RequestExecutorMockSaveParams{ctx, current, res}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSave.t.Errorf("RequestExecutorMock.Save got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSave.SaveMock.defaultExpectation.results
		if mm_results == nil {
			mmSave.t.Fatal("No results are set for the RequestExecutorMock.Save")
		}
		return (*mm_results).err
	}
	if mmSave.funcSave != nil {
		return mmSave.funcSave(ctx, current, res)
	}
	mmSave.t.Fatalf("Unexpected call to RequestExecutorMock.Save. %v %v %v", ctx, current, res)
	return
}

// SaveAfterCounter returns a count of finished RequestExecutorMock.Save invocations
func (mmSave *RequestExecutorMock) SaveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSave.afterSaveCounter)
}

// SaveBeforeCounter returns a count of RequestExecutorMock.Save invocations
func (mmSave *RequestExecutorMock) SaveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSave.beforeSaveCounter)
}

// Calls returns a list of arguments used in each call to RequestExecutorMock.Save.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSave *mRequestExecutorMockSave) Calls() []*RequestExecutorMockSaveParams {
	mmSave.mutex.RLock()

	argCopy := make([]*RequestExecutorMockSaveParams, len(mmSave.callArgs))
	copy(argCopy, mmSave.callArgs)

	mmSave.mutex.RUnlock()

	return argCopy
}

// MinimockSaveDone returns true if the count of the Save invocations corresponds
// the number of defined expectations
func (m *RequestExecutorMock) MinimockSaveDone() bool {
	for _, e := range m.SaveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SaveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSaveCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSave != nil && mm_atomic.LoadUint64(&m.afterSaveCounter) < 1 {
		return false
	}
	return true
}

// MinimockSaveInspect logs each unmet expectation
func (m *RequestExecutorMock) MinimockSaveInspect() {
	for _, e := range m.SaveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RequestExecutorMock.Save with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SaveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSaveCounter) < 1 {
		if m.SaveMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RequestExecutorMock.Save")
		} else {
			m.t.Errorf("Expected call to RequestExecutorMock.Save with params: %#v", *m.SaveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSave != nil && mm_atomic.LoadUint64(&m.afterSaveCounter) < 1 {
		m.t.Error("Expected call to RequestExecutorMock.Save")
	}
}

type mRequestExecutorMockSendReply struct {
	mock               *RequestExecutorMock
	defaultExpectation *RequestExecutorMockSendReplyExpectation
	expectations       []*RequestExecutorMockSendReplyExpectation

	callArgs []*RequestExecutorMockSendReplyParams
	mutex    sync.RWMutex
}

// RequestExecutorMockSendReplyExpectation specifies expectation struct of the RequestExecutor.SendReply
type RequestExecutorMockSendReplyExpectation struct {
	mock   *RequestExecutorMock
	params *RequestExecutorMockSendReplyParams

	Counter uint64
}

// RequestExecutorMockSendReplyParams contains parameters of the RequestExecutor.SendReply
type RequestExecutorMockSendReplyParams struct {
	ctx    context.Context
	reqRef insolar.Reference
	req    record.IncomingRequest
	re     insolar.Reply
	err    error
}

// Expect sets up expected params for RequestExecutor.SendReply
func (mmSendReply *mRequestExecutorMockSendReply) Expect(ctx context.Context, reqRef insolar.Reference, req record.IncomingRequest, re insolar.Reply, err error) *mRequestExecutorMockSendReply {
	if mmSendReply.mock.funcSendReply != nil {
		mmSendReply.mock.t.Fatalf("RequestExecutorMock.SendReply mock is already set by Set")
	}

	if mmSendReply.defaultExpectation == nil {
		mmSendReply.defaultExpectation = &RequestExecutorMockSendReplyExpectation{}
	}

	mmSendReply.defaultExpectation.params = &RequestExecutorMockSendReplyParams{ctx, reqRef, req, re, err}
	for _, e := range mmSendReply.expectations {
		if minimock.Equal(e.params, mmSendReply.defaultExpectation.params) {
			mmSendReply.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendReply.defaultExpectation.params)
		}
	}

	return mmSendReply
}

// Inspect accepts an inspector function that has same arguments as the RequestExecutor.SendReply
func (mmSendReply *mRequestExecutorMockSendReply) Inspect(f func(ctx context.Context, reqRef insolar.Reference, req record.IncomingRequest, re insolar.Reply, err error)) *mRequestExecutorMockSendReply {
	if mmSendReply.mock.inspectFuncSendReply != nil {
		mmSendReply.mock.t.Fatalf("Inspect function is already set for RequestExecutorMock.SendReply")
	}

	mmSendReply.mock.inspectFuncSendReply = f

	return mmSendReply
}

// Return sets up results that will be returned by RequestExecutor.SendReply
func (mmSendReply *mRequestExecutorMockSendReply) Return() *RequestExecutorMock {
	if mmSendReply.mock.funcSendReply != nil {
		mmSendReply.mock.t.Fatalf("RequestExecutorMock.SendReply mock is already set by Set")
	}

	if mmSendReply.defaultExpectation == nil {
		mmSendReply.defaultExpectation = &RequestExecutorMockSendReplyExpectation{mock: mmSendReply.mock}
	}

	return mmSendReply.mock
}

//Set uses given function f to mock the RequestExecutor.SendReply method
func (mmSendReply *mRequestExecutorMockSendReply) Set(f func(ctx context.Context, reqRef insolar.Reference, req record.IncomingRequest, re insolar.Reply, err error)) *RequestExecutorMock {
	if mmSendReply.defaultExpectation != nil {
		mmSendReply.mock.t.Fatalf("Default expectation is already set for the RequestExecutor.SendReply method")
	}

	if len(mmSendReply.expectations) > 0 {
		mmSendReply.mock.t.Fatalf("Some expectations are already set for the RequestExecutor.SendReply method")
	}

	mmSendReply.mock.funcSendReply = f
	return mmSendReply.mock
}

// SendReply implements RequestExecutor
func (mmSendReply *RequestExecutorMock) SendReply(ctx context.Context, reqRef insolar.Reference, req record.IncomingRequest, re insolar.Reply, err error) {
	mm_atomic.AddUint64(&mmSendReply.beforeSendReplyCounter, 1)
	defer mm_atomic.AddUint64(&mmSendReply.afterSendReplyCounter, 1)

	if mmSendReply.inspectFuncSendReply != nil {
		mmSendReply.inspectFuncSendReply(ctx, reqRef, req, re, err)
	}

	mm_params := &RequestExecutorMockSendReplyParams{ctx, reqRef, req, re, err}

	// Record call args
	mmSendReply.SendReplyMock.mutex.Lock()
	mmSendReply.SendReplyMock.callArgs = append(mmSendReply.SendReplyMock.callArgs, mm_params)
	mmSendReply.SendReplyMock.mutex.Unlock()

	for _, e := range mmSendReply.SendReplyMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSendReply.SendReplyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendReply.SendReplyMock.defaultExpectation.Counter, 1)
		mm_want := mmSendReply.SendReplyMock.defaultExpectation.params
		mm_got := RequestExecutorMockSendReplyParams{ctx, reqRef, req, re, err}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendReply.t.Errorf("RequestExecutorMock.SendReply got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSendReply.funcSendReply != nil {
		mmSendReply.funcSendReply(ctx, reqRef, req, re, err)
		return
	}
	mmSendReply.t.Fatalf("Unexpected call to RequestExecutorMock.SendReply. %v %v %v %v %v", ctx, reqRef, req, re, err)

}

// SendReplyAfterCounter returns a count of finished RequestExecutorMock.SendReply invocations
func (mmSendReply *RequestExecutorMock) SendReplyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendReply.afterSendReplyCounter)
}

// SendReplyBeforeCounter returns a count of RequestExecutorMock.SendReply invocations
func (mmSendReply *RequestExecutorMock) SendReplyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendReply.beforeSendReplyCounter)
}

// Calls returns a list of arguments used in each call to RequestExecutorMock.SendReply.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendReply *mRequestExecutorMockSendReply) Calls() []*RequestExecutorMockSendReplyParams {
	mmSendReply.mutex.RLock()

	argCopy := make([]*RequestExecutorMockSendReplyParams, len(mmSendReply.callArgs))
	copy(argCopy, mmSendReply.callArgs)

	mmSendReply.mutex.RUnlock()

	return argCopy
}

// MinimockSendReplyDone returns true if the count of the SendReply invocations corresponds
// the number of defined expectations
func (m *RequestExecutorMock) MinimockSendReplyDone() bool {
	for _, e := range m.SendReplyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendReplyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendReplyCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendReply != nil && mm_atomic.LoadUint64(&m.afterSendReplyCounter) < 1 {
		return false
	}
	return true
}

// MinimockSendReplyInspect logs each unmet expectation
func (m *RequestExecutorMock) MinimockSendReplyInspect() {
	for _, e := range m.SendReplyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RequestExecutorMock.SendReply with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendReplyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendReplyCounter) < 1 {
		if m.SendReplyMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RequestExecutorMock.SendReply")
		} else {
			m.t.Errorf("Expected call to RequestExecutorMock.SendReply with params: %#v", *m.SendReplyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendReply != nil && mm_atomic.LoadUint64(&m.afterSendReplyCounter) < 1 {
		m.t.Error("Expected call to RequestExecutorMock.SendReply")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RequestExecutorMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockExecuteInspect()

		m.MinimockExecuteAndSaveInspect()

		m.MinimockSaveInspect()

		m.MinimockSendReplyInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RequestExecutorMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RequestExecutorMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockExecuteDone() &&
		m.MinimockExecuteAndSaveDone() &&
		m.MinimockSaveDone() &&
		m.MinimockSendReplyDone()
}
