package testutils

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	mm_insolar "github.com/insolar/insolar/insolar"
)

// ParcelMock implements insolar.Parcel
type ParcelMock struct {
	t minimock.Tester

	funcAllowedSenderObjectAndRole          func() (rp1 *mm_insolar.Reference, d1 mm_insolar.DynamicRole)
	inspectFuncAllowedSenderObjectAndRole   func()
	afterAllowedSenderObjectAndRoleCounter  uint64
	beforeAllowedSenderObjectAndRoleCounter uint64
	AllowedSenderObjectAndRoleMock          mParcelMockAllowedSenderObjectAndRole

	funcContext          func(ctx context.Context) (c2 context.Context)
	inspectFuncContext   func(ctx context.Context)
	afterContextCounter  uint64
	beforeContextCounter uint64
	ContextMock          mParcelMockContext

	funcDefaultRole          func() (d1 mm_insolar.DynamicRole)
	inspectFuncDefaultRole   func()
	afterDefaultRoleCounter  uint64
	beforeDefaultRoleCounter uint64
	DefaultRoleMock          mParcelMockDefaultRole

	funcDefaultTarget          func() (rp1 *mm_insolar.Reference)
	inspectFuncDefaultTarget   func()
	afterDefaultTargetCounter  uint64
	beforeDefaultTargetCounter uint64
	DefaultTargetMock          mParcelMockDefaultTarget

	funcGetCaller          func() (rp1 *mm_insolar.Reference)
	inspectFuncGetCaller   func()
	afterGetCallerCounter  uint64
	beforeGetCallerCounter uint64
	GetCallerMock          mParcelMockGetCaller

	funcGetSender          func() (r1 mm_insolar.Reference)
	inspectFuncGetSender   func()
	afterGetSenderCounter  uint64
	beforeGetSenderCounter uint64
	GetSenderMock          mParcelMockGetSender

	funcGetSign          func() (ba1 []byte)
	inspectFuncGetSign   func()
	afterGetSignCounter  uint64
	beforeGetSignCounter uint64
	GetSignMock          mParcelMockGetSign

	funcMessage          func() (m1 mm_insolar.Message)
	inspectFuncMessage   func()
	afterMessageCounter  uint64
	beforeMessageCounter uint64
	MessageMock          mParcelMockMessage

	funcPulse          func() (p1 mm_insolar.PulseNumber)
	inspectFuncPulse   func()
	afterPulseCounter  uint64
	beforePulseCounter uint64
	PulseMock          mParcelMockPulse

	funcSetSender          func(r1 mm_insolar.Reference)
	inspectFuncSetSender   func(r1 mm_insolar.Reference)
	afterSetSenderCounter  uint64
	beforeSetSenderCounter uint64
	SetSenderMock          mParcelMockSetSender

	funcType          func() (m1 mm_insolar.MessageType)
	inspectFuncType   func()
	afterTypeCounter  uint64
	beforeTypeCounter uint64
	TypeMock          mParcelMockType
}

// NewParcelMock returns a mock for insolar.Parcel
func NewParcelMock(t minimock.Tester) *ParcelMock {
	m := &ParcelMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AllowedSenderObjectAndRoleMock = mParcelMockAllowedSenderObjectAndRole{mock: m}

	m.ContextMock = mParcelMockContext{mock: m}
	m.ContextMock.callArgs = []*ParcelMockContextParams{}

	m.DefaultRoleMock = mParcelMockDefaultRole{mock: m}

	m.DefaultTargetMock = mParcelMockDefaultTarget{mock: m}

	m.GetCallerMock = mParcelMockGetCaller{mock: m}

	m.GetSenderMock = mParcelMockGetSender{mock: m}

	m.GetSignMock = mParcelMockGetSign{mock: m}

	m.MessageMock = mParcelMockMessage{mock: m}

	m.PulseMock = mParcelMockPulse{mock: m}

	m.SetSenderMock = mParcelMockSetSender{mock: m}
	m.SetSenderMock.callArgs = []*ParcelMockSetSenderParams{}

	m.TypeMock = mParcelMockType{mock: m}

	return m
}

type mParcelMockAllowedSenderObjectAndRole struct {
	mock               *ParcelMock
	defaultExpectation *ParcelMockAllowedSenderObjectAndRoleExpectation
	expectations       []*ParcelMockAllowedSenderObjectAndRoleExpectation
}

// ParcelMockAllowedSenderObjectAndRoleExpectation specifies expectation struct of the Parcel.AllowedSenderObjectAndRole
type ParcelMockAllowedSenderObjectAndRoleExpectation struct {
	mock *ParcelMock

	results *ParcelMockAllowedSenderObjectAndRoleResults
	Counter uint64
}

// ParcelMockAllowedSenderObjectAndRoleResults contains results of the Parcel.AllowedSenderObjectAndRole
type ParcelMockAllowedSenderObjectAndRoleResults struct {
	rp1 *mm_insolar.Reference
	d1  mm_insolar.DynamicRole
}

// Expect sets up expected params for Parcel.AllowedSenderObjectAndRole
func (mmAllowedSenderObjectAndRole *mParcelMockAllowedSenderObjectAndRole) Expect() *mParcelMockAllowedSenderObjectAndRole {
	if mmAllowedSenderObjectAndRole.mock.funcAllowedSenderObjectAndRole != nil {
		mmAllowedSenderObjectAndRole.mock.t.Fatalf("ParcelMock.AllowedSenderObjectAndRole mock is already set by Set")
	}

	if mmAllowedSenderObjectAndRole.defaultExpectation == nil {
		mmAllowedSenderObjectAndRole.defaultExpectation = &ParcelMockAllowedSenderObjectAndRoleExpectation{}
	}

	return mmAllowedSenderObjectAndRole
}

// Inspect accepts an inspector function that has same arguments as the Parcel.AllowedSenderObjectAndRole
func (mmAllowedSenderObjectAndRole *mParcelMockAllowedSenderObjectAndRole) Inspect(f func()) *mParcelMockAllowedSenderObjectAndRole {
	if mmAllowedSenderObjectAndRole.mock.inspectFuncAllowedSenderObjectAndRole != nil {
		mmAllowedSenderObjectAndRole.mock.t.Fatalf("Inspect function is already set for ParcelMock.AllowedSenderObjectAndRole")
	}

	mmAllowedSenderObjectAndRole.mock.inspectFuncAllowedSenderObjectAndRole = f

	return mmAllowedSenderObjectAndRole
}

// Return sets up results that will be returned by Parcel.AllowedSenderObjectAndRole
func (mmAllowedSenderObjectAndRole *mParcelMockAllowedSenderObjectAndRole) Return(rp1 *mm_insolar.Reference, d1 mm_insolar.DynamicRole) *ParcelMock {
	if mmAllowedSenderObjectAndRole.mock.funcAllowedSenderObjectAndRole != nil {
		mmAllowedSenderObjectAndRole.mock.t.Fatalf("ParcelMock.AllowedSenderObjectAndRole mock is already set by Set")
	}

	if mmAllowedSenderObjectAndRole.defaultExpectation == nil {
		mmAllowedSenderObjectAndRole.defaultExpectation = &ParcelMockAllowedSenderObjectAndRoleExpectation{mock: mmAllowedSenderObjectAndRole.mock}
	}
	mmAllowedSenderObjectAndRole.defaultExpectation.results = &ParcelMockAllowedSenderObjectAndRoleResults{rp1, d1}
	return mmAllowedSenderObjectAndRole.mock
}

//Set uses given function f to mock the Parcel.AllowedSenderObjectAndRole method
func (mmAllowedSenderObjectAndRole *mParcelMockAllowedSenderObjectAndRole) Set(f func() (rp1 *mm_insolar.Reference, d1 mm_insolar.DynamicRole)) *ParcelMock {
	if mmAllowedSenderObjectAndRole.defaultExpectation != nil {
		mmAllowedSenderObjectAndRole.mock.t.Fatalf("Default expectation is already set for the Parcel.AllowedSenderObjectAndRole method")
	}

	if len(mmAllowedSenderObjectAndRole.expectations) > 0 {
		mmAllowedSenderObjectAndRole.mock.t.Fatalf("Some expectations are already set for the Parcel.AllowedSenderObjectAndRole method")
	}

	mmAllowedSenderObjectAndRole.mock.funcAllowedSenderObjectAndRole = f
	return mmAllowedSenderObjectAndRole.mock
}

// AllowedSenderObjectAndRole implements insolar.Parcel
func (mmAllowedSenderObjectAndRole *ParcelMock) AllowedSenderObjectAndRole() (rp1 *mm_insolar.Reference, d1 mm_insolar.DynamicRole) {
	mm_atomic.AddUint64(&mmAllowedSenderObjectAndRole.beforeAllowedSenderObjectAndRoleCounter, 1)
	defer mm_atomic.AddUint64(&mmAllowedSenderObjectAndRole.afterAllowedSenderObjectAndRoleCounter, 1)

	if mmAllowedSenderObjectAndRole.inspectFuncAllowedSenderObjectAndRole != nil {
		mmAllowedSenderObjectAndRole.inspectFuncAllowedSenderObjectAndRole()
	}

	if mmAllowedSenderObjectAndRole.AllowedSenderObjectAndRoleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAllowedSenderObjectAndRole.AllowedSenderObjectAndRoleMock.defaultExpectation.Counter, 1)

		results := mmAllowedSenderObjectAndRole.AllowedSenderObjectAndRoleMock.defaultExpectation.results
		if results == nil {
			mmAllowedSenderObjectAndRole.t.Fatal("No results are set for the ParcelMock.AllowedSenderObjectAndRole")
		}
		return (*results).rp1, (*results).d1
	}
	if mmAllowedSenderObjectAndRole.funcAllowedSenderObjectAndRole != nil {
		return mmAllowedSenderObjectAndRole.funcAllowedSenderObjectAndRole()
	}
	mmAllowedSenderObjectAndRole.t.Fatalf("Unexpected call to ParcelMock.AllowedSenderObjectAndRole.")
	return
}

// AllowedSenderObjectAndRoleAfterCounter returns a count of finished ParcelMock.AllowedSenderObjectAndRole invocations
func (mmAllowedSenderObjectAndRole *ParcelMock) AllowedSenderObjectAndRoleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAllowedSenderObjectAndRole.afterAllowedSenderObjectAndRoleCounter)
}

// AllowedSenderObjectAndRoleBeforeCounter returns a count of ParcelMock.AllowedSenderObjectAndRole invocations
func (mmAllowedSenderObjectAndRole *ParcelMock) AllowedSenderObjectAndRoleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAllowedSenderObjectAndRole.beforeAllowedSenderObjectAndRoleCounter)
}

// MinimockAllowedSenderObjectAndRoleDone returns true if the count of the AllowedSenderObjectAndRole invocations corresponds
// the number of defined expectations
func (m *ParcelMock) MinimockAllowedSenderObjectAndRoleDone() bool {
	for _, e := range m.AllowedSenderObjectAndRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AllowedSenderObjectAndRoleMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAllowedSenderObjectAndRoleCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAllowedSenderObjectAndRole != nil && mm_atomic.LoadUint64(&m.afterAllowedSenderObjectAndRoleCounter) < 1 {
		return false
	}
	return true
}

// MinimockAllowedSenderObjectAndRoleInspect logs each unmet expectation
func (m *ParcelMock) MinimockAllowedSenderObjectAndRoleInspect() {
	for _, e := range m.AllowedSenderObjectAndRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ParcelMock.AllowedSenderObjectAndRole")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AllowedSenderObjectAndRoleMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAllowedSenderObjectAndRoleCounter) < 1 {
		m.t.Error("Expected call to ParcelMock.AllowedSenderObjectAndRole")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAllowedSenderObjectAndRole != nil && mm_atomic.LoadUint64(&m.afterAllowedSenderObjectAndRoleCounter) < 1 {
		m.t.Error("Expected call to ParcelMock.AllowedSenderObjectAndRole")
	}
}

type mParcelMockContext struct {
	mock               *ParcelMock
	defaultExpectation *ParcelMockContextExpectation
	expectations       []*ParcelMockContextExpectation

	callArgs []*ParcelMockContextParams
	mutex    sync.RWMutex
}

// ParcelMockContextExpectation specifies expectation struct of the Parcel.Context
type ParcelMockContextExpectation struct {
	mock    *ParcelMock
	params  *ParcelMockContextParams
	results *ParcelMockContextResults
	Counter uint64
}

// ParcelMockContextParams contains parameters of the Parcel.Context
type ParcelMockContextParams struct {
	ctx context.Context
}

// ParcelMockContextResults contains results of the Parcel.Context
type ParcelMockContextResults struct {
	c2 context.Context
}

// Expect sets up expected params for Parcel.Context
func (mmContext *mParcelMockContext) Expect(ctx context.Context) *mParcelMockContext {
	if mmContext.mock.funcContext != nil {
		mmContext.mock.t.Fatalf("ParcelMock.Context mock is already set by Set")
	}

	if mmContext.defaultExpectation == nil {
		mmContext.defaultExpectation = &ParcelMockContextExpectation{}
	}

	mmContext.defaultExpectation.params = &ParcelMockContextParams{ctx}
	for _, e := range mmContext.expectations {
		if minimock.Equal(e.params, mmContext.defaultExpectation.params) {
			mmContext.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmContext.defaultExpectation.params)
		}
	}

	return mmContext
}

// Inspect accepts an inspector function that has same arguments as the Parcel.Context
func (mmContext *mParcelMockContext) Inspect(f func(ctx context.Context)) *mParcelMockContext {
	if mmContext.mock.inspectFuncContext != nil {
		mmContext.mock.t.Fatalf("Inspect function is already set for ParcelMock.Context")
	}

	mmContext.mock.inspectFuncContext = f

	return mmContext
}

// Return sets up results that will be returned by Parcel.Context
func (mmContext *mParcelMockContext) Return(c2 context.Context) *ParcelMock {
	if mmContext.mock.funcContext != nil {
		mmContext.mock.t.Fatalf("ParcelMock.Context mock is already set by Set")
	}

	if mmContext.defaultExpectation == nil {
		mmContext.defaultExpectation = &ParcelMockContextExpectation{mock: mmContext.mock}
	}
	mmContext.defaultExpectation.results = &ParcelMockContextResults{c2}
	return mmContext.mock
}

//Set uses given function f to mock the Parcel.Context method
func (mmContext *mParcelMockContext) Set(f func(ctx context.Context) (c2 context.Context)) *ParcelMock {
	if mmContext.defaultExpectation != nil {
		mmContext.mock.t.Fatalf("Default expectation is already set for the Parcel.Context method")
	}

	if len(mmContext.expectations) > 0 {
		mmContext.mock.t.Fatalf("Some expectations are already set for the Parcel.Context method")
	}

	mmContext.mock.funcContext = f
	return mmContext.mock
}

// When sets expectation for the Parcel.Context which will trigger the result defined by the following
// Then helper
func (mmContext *mParcelMockContext) When(ctx context.Context) *ParcelMockContextExpectation {
	if mmContext.mock.funcContext != nil {
		mmContext.mock.t.Fatalf("ParcelMock.Context mock is already set by Set")
	}

	expectation := &ParcelMockContextExpectation{
		mock:   mmContext.mock,
		params: &ParcelMockContextParams{ctx},
	}
	mmContext.expectations = append(mmContext.expectations, expectation)
	return expectation
}

// Then sets up Parcel.Context return parameters for the expectation previously defined by the When method
func (e *ParcelMockContextExpectation) Then(c2 context.Context) *ParcelMock {
	e.results = &ParcelMockContextResults{c2}
	return e.mock
}

// Context implements insolar.Parcel
func (mmContext *ParcelMock) Context(ctx context.Context) (c2 context.Context) {
	mm_atomic.AddUint64(&mmContext.beforeContextCounter, 1)
	defer mm_atomic.AddUint64(&mmContext.afterContextCounter, 1)

	if mmContext.inspectFuncContext != nil {
		mmContext.inspectFuncContext(ctx)
	}

	params := &ParcelMockContextParams{ctx}

	// Record call args
	mmContext.ContextMock.mutex.Lock()
	mmContext.ContextMock.callArgs = append(mmContext.ContextMock.callArgs, params)
	mmContext.ContextMock.mutex.Unlock()

	for _, e := range mmContext.ContextMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c2
		}
	}

	if mmContext.ContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmContext.ContextMock.defaultExpectation.Counter, 1)
		want := mmContext.ContextMock.defaultExpectation.params
		got := ParcelMockContextParams{ctx}
		if want != nil && !minimock.Equal(*want, got) {
			mmContext.t.Errorf("ParcelMock.Context got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmContext.ContextMock.defaultExpectation.results
		if results == nil {
			mmContext.t.Fatal("No results are set for the ParcelMock.Context")
		}
		return (*results).c2
	}
	if mmContext.funcContext != nil {
		return mmContext.funcContext(ctx)
	}
	mmContext.t.Fatalf("Unexpected call to ParcelMock.Context. %v", ctx)
	return
}

// ContextAfterCounter returns a count of finished ParcelMock.Context invocations
func (mmContext *ParcelMock) ContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmContext.afterContextCounter)
}

// ContextBeforeCounter returns a count of ParcelMock.Context invocations
func (mmContext *ParcelMock) ContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmContext.beforeContextCounter)
}

// Calls returns a list of arguments used in each call to ParcelMock.Context.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmContext *mParcelMockContext) Calls() []*ParcelMockContextParams {
	mmContext.mutex.RLock()

	argCopy := make([]*ParcelMockContextParams, len(mmContext.callArgs))
	copy(argCopy, mmContext.callArgs)

	mmContext.mutex.RUnlock()

	return argCopy
}

// MinimockContextDone returns true if the count of the Context invocations corresponds
// the number of defined expectations
func (m *ParcelMock) MinimockContextDone() bool {
	for _, e := range m.ContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterContextCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcContext != nil && mm_atomic.LoadUint64(&m.afterContextCounter) < 1 {
		return false
	}
	return true
}

// MinimockContextInspect logs each unmet expectation
func (m *ParcelMock) MinimockContextInspect() {
	for _, e := range m.ContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ParcelMock.Context with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterContextCounter) < 1 {
		if m.ContextMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ParcelMock.Context")
		} else {
			m.t.Errorf("Expected call to ParcelMock.Context with params: %#v", *m.ContextMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcContext != nil && mm_atomic.LoadUint64(&m.afterContextCounter) < 1 {
		m.t.Error("Expected call to ParcelMock.Context")
	}
}

type mParcelMockDefaultRole struct {
	mock               *ParcelMock
	defaultExpectation *ParcelMockDefaultRoleExpectation
	expectations       []*ParcelMockDefaultRoleExpectation
}

// ParcelMockDefaultRoleExpectation specifies expectation struct of the Parcel.DefaultRole
type ParcelMockDefaultRoleExpectation struct {
	mock *ParcelMock

	results *ParcelMockDefaultRoleResults
	Counter uint64
}

// ParcelMockDefaultRoleResults contains results of the Parcel.DefaultRole
type ParcelMockDefaultRoleResults struct {
	d1 mm_insolar.DynamicRole
}

// Expect sets up expected params for Parcel.DefaultRole
func (mmDefaultRole *mParcelMockDefaultRole) Expect() *mParcelMockDefaultRole {
	if mmDefaultRole.mock.funcDefaultRole != nil {
		mmDefaultRole.mock.t.Fatalf("ParcelMock.DefaultRole mock is already set by Set")
	}

	if mmDefaultRole.defaultExpectation == nil {
		mmDefaultRole.defaultExpectation = &ParcelMockDefaultRoleExpectation{}
	}

	return mmDefaultRole
}

// Inspect accepts an inspector function that has same arguments as the Parcel.DefaultRole
func (mmDefaultRole *mParcelMockDefaultRole) Inspect(f func()) *mParcelMockDefaultRole {
	if mmDefaultRole.mock.inspectFuncDefaultRole != nil {
		mmDefaultRole.mock.t.Fatalf("Inspect function is already set for ParcelMock.DefaultRole")
	}

	mmDefaultRole.mock.inspectFuncDefaultRole = f

	return mmDefaultRole
}

// Return sets up results that will be returned by Parcel.DefaultRole
func (mmDefaultRole *mParcelMockDefaultRole) Return(d1 mm_insolar.DynamicRole) *ParcelMock {
	if mmDefaultRole.mock.funcDefaultRole != nil {
		mmDefaultRole.mock.t.Fatalf("ParcelMock.DefaultRole mock is already set by Set")
	}

	if mmDefaultRole.defaultExpectation == nil {
		mmDefaultRole.defaultExpectation = &ParcelMockDefaultRoleExpectation{mock: mmDefaultRole.mock}
	}
	mmDefaultRole.defaultExpectation.results = &ParcelMockDefaultRoleResults{d1}
	return mmDefaultRole.mock
}

//Set uses given function f to mock the Parcel.DefaultRole method
func (mmDefaultRole *mParcelMockDefaultRole) Set(f func() (d1 mm_insolar.DynamicRole)) *ParcelMock {
	if mmDefaultRole.defaultExpectation != nil {
		mmDefaultRole.mock.t.Fatalf("Default expectation is already set for the Parcel.DefaultRole method")
	}

	if len(mmDefaultRole.expectations) > 0 {
		mmDefaultRole.mock.t.Fatalf("Some expectations are already set for the Parcel.DefaultRole method")
	}

	mmDefaultRole.mock.funcDefaultRole = f
	return mmDefaultRole.mock
}

// DefaultRole implements insolar.Parcel
func (mmDefaultRole *ParcelMock) DefaultRole() (d1 mm_insolar.DynamicRole) {
	mm_atomic.AddUint64(&mmDefaultRole.beforeDefaultRoleCounter, 1)
	defer mm_atomic.AddUint64(&mmDefaultRole.afterDefaultRoleCounter, 1)

	if mmDefaultRole.inspectFuncDefaultRole != nil {
		mmDefaultRole.inspectFuncDefaultRole()
	}

	if mmDefaultRole.DefaultRoleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDefaultRole.DefaultRoleMock.defaultExpectation.Counter, 1)

		results := mmDefaultRole.DefaultRoleMock.defaultExpectation.results
		if results == nil {
			mmDefaultRole.t.Fatal("No results are set for the ParcelMock.DefaultRole")
		}
		return (*results).d1
	}
	if mmDefaultRole.funcDefaultRole != nil {
		return mmDefaultRole.funcDefaultRole()
	}
	mmDefaultRole.t.Fatalf("Unexpected call to ParcelMock.DefaultRole.")
	return
}

// DefaultRoleAfterCounter returns a count of finished ParcelMock.DefaultRole invocations
func (mmDefaultRole *ParcelMock) DefaultRoleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDefaultRole.afterDefaultRoleCounter)
}

// DefaultRoleBeforeCounter returns a count of ParcelMock.DefaultRole invocations
func (mmDefaultRole *ParcelMock) DefaultRoleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDefaultRole.beforeDefaultRoleCounter)
}

// MinimockDefaultRoleDone returns true if the count of the DefaultRole invocations corresponds
// the number of defined expectations
func (m *ParcelMock) MinimockDefaultRoleDone() bool {
	for _, e := range m.DefaultRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DefaultRoleMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDefaultRoleCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDefaultRole != nil && mm_atomic.LoadUint64(&m.afterDefaultRoleCounter) < 1 {
		return false
	}
	return true
}

// MinimockDefaultRoleInspect logs each unmet expectation
func (m *ParcelMock) MinimockDefaultRoleInspect() {
	for _, e := range m.DefaultRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ParcelMock.DefaultRole")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DefaultRoleMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDefaultRoleCounter) < 1 {
		m.t.Error("Expected call to ParcelMock.DefaultRole")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDefaultRole != nil && mm_atomic.LoadUint64(&m.afterDefaultRoleCounter) < 1 {
		m.t.Error("Expected call to ParcelMock.DefaultRole")
	}
}

type mParcelMockDefaultTarget struct {
	mock               *ParcelMock
	defaultExpectation *ParcelMockDefaultTargetExpectation
	expectations       []*ParcelMockDefaultTargetExpectation
}

// ParcelMockDefaultTargetExpectation specifies expectation struct of the Parcel.DefaultTarget
type ParcelMockDefaultTargetExpectation struct {
	mock *ParcelMock

	results *ParcelMockDefaultTargetResults
	Counter uint64
}

// ParcelMockDefaultTargetResults contains results of the Parcel.DefaultTarget
type ParcelMockDefaultTargetResults struct {
	rp1 *mm_insolar.Reference
}

// Expect sets up expected params for Parcel.DefaultTarget
func (mmDefaultTarget *mParcelMockDefaultTarget) Expect() *mParcelMockDefaultTarget {
	if mmDefaultTarget.mock.funcDefaultTarget != nil {
		mmDefaultTarget.mock.t.Fatalf("ParcelMock.DefaultTarget mock is already set by Set")
	}

	if mmDefaultTarget.defaultExpectation == nil {
		mmDefaultTarget.defaultExpectation = &ParcelMockDefaultTargetExpectation{}
	}

	return mmDefaultTarget
}

// Inspect accepts an inspector function that has same arguments as the Parcel.DefaultTarget
func (mmDefaultTarget *mParcelMockDefaultTarget) Inspect(f func()) *mParcelMockDefaultTarget {
	if mmDefaultTarget.mock.inspectFuncDefaultTarget != nil {
		mmDefaultTarget.mock.t.Fatalf("Inspect function is already set for ParcelMock.DefaultTarget")
	}

	mmDefaultTarget.mock.inspectFuncDefaultTarget = f

	return mmDefaultTarget
}

// Return sets up results that will be returned by Parcel.DefaultTarget
func (mmDefaultTarget *mParcelMockDefaultTarget) Return(rp1 *mm_insolar.Reference) *ParcelMock {
	if mmDefaultTarget.mock.funcDefaultTarget != nil {
		mmDefaultTarget.mock.t.Fatalf("ParcelMock.DefaultTarget mock is already set by Set")
	}

	if mmDefaultTarget.defaultExpectation == nil {
		mmDefaultTarget.defaultExpectation = &ParcelMockDefaultTargetExpectation{mock: mmDefaultTarget.mock}
	}
	mmDefaultTarget.defaultExpectation.results = &ParcelMockDefaultTargetResults{rp1}
	return mmDefaultTarget.mock
}

//Set uses given function f to mock the Parcel.DefaultTarget method
func (mmDefaultTarget *mParcelMockDefaultTarget) Set(f func() (rp1 *mm_insolar.Reference)) *ParcelMock {
	if mmDefaultTarget.defaultExpectation != nil {
		mmDefaultTarget.mock.t.Fatalf("Default expectation is already set for the Parcel.DefaultTarget method")
	}

	if len(mmDefaultTarget.expectations) > 0 {
		mmDefaultTarget.mock.t.Fatalf("Some expectations are already set for the Parcel.DefaultTarget method")
	}

	mmDefaultTarget.mock.funcDefaultTarget = f
	return mmDefaultTarget.mock
}

// DefaultTarget implements insolar.Parcel
func (mmDefaultTarget *ParcelMock) DefaultTarget() (rp1 *mm_insolar.Reference) {
	mm_atomic.AddUint64(&mmDefaultTarget.beforeDefaultTargetCounter, 1)
	defer mm_atomic.AddUint64(&mmDefaultTarget.afterDefaultTargetCounter, 1)

	if mmDefaultTarget.inspectFuncDefaultTarget != nil {
		mmDefaultTarget.inspectFuncDefaultTarget()
	}

	if mmDefaultTarget.DefaultTargetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDefaultTarget.DefaultTargetMock.defaultExpectation.Counter, 1)

		results := mmDefaultTarget.DefaultTargetMock.defaultExpectation.results
		if results == nil {
			mmDefaultTarget.t.Fatal("No results are set for the ParcelMock.DefaultTarget")
		}
		return (*results).rp1
	}
	if mmDefaultTarget.funcDefaultTarget != nil {
		return mmDefaultTarget.funcDefaultTarget()
	}
	mmDefaultTarget.t.Fatalf("Unexpected call to ParcelMock.DefaultTarget.")
	return
}

// DefaultTargetAfterCounter returns a count of finished ParcelMock.DefaultTarget invocations
func (mmDefaultTarget *ParcelMock) DefaultTargetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDefaultTarget.afterDefaultTargetCounter)
}

// DefaultTargetBeforeCounter returns a count of ParcelMock.DefaultTarget invocations
func (mmDefaultTarget *ParcelMock) DefaultTargetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDefaultTarget.beforeDefaultTargetCounter)
}

// MinimockDefaultTargetDone returns true if the count of the DefaultTarget invocations corresponds
// the number of defined expectations
func (m *ParcelMock) MinimockDefaultTargetDone() bool {
	for _, e := range m.DefaultTargetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DefaultTargetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDefaultTargetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDefaultTarget != nil && mm_atomic.LoadUint64(&m.afterDefaultTargetCounter) < 1 {
		return false
	}
	return true
}

// MinimockDefaultTargetInspect logs each unmet expectation
func (m *ParcelMock) MinimockDefaultTargetInspect() {
	for _, e := range m.DefaultTargetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ParcelMock.DefaultTarget")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DefaultTargetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDefaultTargetCounter) < 1 {
		m.t.Error("Expected call to ParcelMock.DefaultTarget")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDefaultTarget != nil && mm_atomic.LoadUint64(&m.afterDefaultTargetCounter) < 1 {
		m.t.Error("Expected call to ParcelMock.DefaultTarget")
	}
}

type mParcelMockGetCaller struct {
	mock               *ParcelMock
	defaultExpectation *ParcelMockGetCallerExpectation
	expectations       []*ParcelMockGetCallerExpectation
}

// ParcelMockGetCallerExpectation specifies expectation struct of the Parcel.GetCaller
type ParcelMockGetCallerExpectation struct {
	mock *ParcelMock

	results *ParcelMockGetCallerResults
	Counter uint64
}

// ParcelMockGetCallerResults contains results of the Parcel.GetCaller
type ParcelMockGetCallerResults struct {
	rp1 *mm_insolar.Reference
}

// Expect sets up expected params for Parcel.GetCaller
func (mmGetCaller *mParcelMockGetCaller) Expect() *mParcelMockGetCaller {
	if mmGetCaller.mock.funcGetCaller != nil {
		mmGetCaller.mock.t.Fatalf("ParcelMock.GetCaller mock is already set by Set")
	}

	if mmGetCaller.defaultExpectation == nil {
		mmGetCaller.defaultExpectation = &ParcelMockGetCallerExpectation{}
	}

	return mmGetCaller
}

// Inspect accepts an inspector function that has same arguments as the Parcel.GetCaller
func (mmGetCaller *mParcelMockGetCaller) Inspect(f func()) *mParcelMockGetCaller {
	if mmGetCaller.mock.inspectFuncGetCaller != nil {
		mmGetCaller.mock.t.Fatalf("Inspect function is already set for ParcelMock.GetCaller")
	}

	mmGetCaller.mock.inspectFuncGetCaller = f

	return mmGetCaller
}

// Return sets up results that will be returned by Parcel.GetCaller
func (mmGetCaller *mParcelMockGetCaller) Return(rp1 *mm_insolar.Reference) *ParcelMock {
	if mmGetCaller.mock.funcGetCaller != nil {
		mmGetCaller.mock.t.Fatalf("ParcelMock.GetCaller mock is already set by Set")
	}

	if mmGetCaller.defaultExpectation == nil {
		mmGetCaller.defaultExpectation = &ParcelMockGetCallerExpectation{mock: mmGetCaller.mock}
	}
	mmGetCaller.defaultExpectation.results = &ParcelMockGetCallerResults{rp1}
	return mmGetCaller.mock
}

//Set uses given function f to mock the Parcel.GetCaller method
func (mmGetCaller *mParcelMockGetCaller) Set(f func() (rp1 *mm_insolar.Reference)) *ParcelMock {
	if mmGetCaller.defaultExpectation != nil {
		mmGetCaller.mock.t.Fatalf("Default expectation is already set for the Parcel.GetCaller method")
	}

	if len(mmGetCaller.expectations) > 0 {
		mmGetCaller.mock.t.Fatalf("Some expectations are already set for the Parcel.GetCaller method")
	}

	mmGetCaller.mock.funcGetCaller = f
	return mmGetCaller.mock
}

// GetCaller implements insolar.Parcel
func (mmGetCaller *ParcelMock) GetCaller() (rp1 *mm_insolar.Reference) {
	mm_atomic.AddUint64(&mmGetCaller.beforeGetCallerCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCaller.afterGetCallerCounter, 1)

	if mmGetCaller.inspectFuncGetCaller != nil {
		mmGetCaller.inspectFuncGetCaller()
	}

	if mmGetCaller.GetCallerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCaller.GetCallerMock.defaultExpectation.Counter, 1)

		results := mmGetCaller.GetCallerMock.defaultExpectation.results
		if results == nil {
			mmGetCaller.t.Fatal("No results are set for the ParcelMock.GetCaller")
		}
		return (*results).rp1
	}
	if mmGetCaller.funcGetCaller != nil {
		return mmGetCaller.funcGetCaller()
	}
	mmGetCaller.t.Fatalf("Unexpected call to ParcelMock.GetCaller.")
	return
}

// GetCallerAfterCounter returns a count of finished ParcelMock.GetCaller invocations
func (mmGetCaller *ParcelMock) GetCallerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCaller.afterGetCallerCounter)
}

// GetCallerBeforeCounter returns a count of ParcelMock.GetCaller invocations
func (mmGetCaller *ParcelMock) GetCallerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCaller.beforeGetCallerCounter)
}

// MinimockGetCallerDone returns true if the count of the GetCaller invocations corresponds
// the number of defined expectations
func (m *ParcelMock) MinimockGetCallerDone() bool {
	for _, e := range m.GetCallerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCallerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCallerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCaller != nil && mm_atomic.LoadUint64(&m.afterGetCallerCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetCallerInspect logs each unmet expectation
func (m *ParcelMock) MinimockGetCallerInspect() {
	for _, e := range m.GetCallerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ParcelMock.GetCaller")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCallerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCallerCounter) < 1 {
		m.t.Error("Expected call to ParcelMock.GetCaller")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCaller != nil && mm_atomic.LoadUint64(&m.afterGetCallerCounter) < 1 {
		m.t.Error("Expected call to ParcelMock.GetCaller")
	}
}

type mParcelMockGetSender struct {
	mock               *ParcelMock
	defaultExpectation *ParcelMockGetSenderExpectation
	expectations       []*ParcelMockGetSenderExpectation
}

// ParcelMockGetSenderExpectation specifies expectation struct of the Parcel.GetSender
type ParcelMockGetSenderExpectation struct {
	mock *ParcelMock

	results *ParcelMockGetSenderResults
	Counter uint64
}

// ParcelMockGetSenderResults contains results of the Parcel.GetSender
type ParcelMockGetSenderResults struct {
	r1 mm_insolar.Reference
}

// Expect sets up expected params for Parcel.GetSender
func (mmGetSender *mParcelMockGetSender) Expect() *mParcelMockGetSender {
	if mmGetSender.mock.funcGetSender != nil {
		mmGetSender.mock.t.Fatalf("ParcelMock.GetSender mock is already set by Set")
	}

	if mmGetSender.defaultExpectation == nil {
		mmGetSender.defaultExpectation = &ParcelMockGetSenderExpectation{}
	}

	return mmGetSender
}

// Inspect accepts an inspector function that has same arguments as the Parcel.GetSender
func (mmGetSender *mParcelMockGetSender) Inspect(f func()) *mParcelMockGetSender {
	if mmGetSender.mock.inspectFuncGetSender != nil {
		mmGetSender.mock.t.Fatalf("Inspect function is already set for ParcelMock.GetSender")
	}

	mmGetSender.mock.inspectFuncGetSender = f

	return mmGetSender
}

// Return sets up results that will be returned by Parcel.GetSender
func (mmGetSender *mParcelMockGetSender) Return(r1 mm_insolar.Reference) *ParcelMock {
	if mmGetSender.mock.funcGetSender != nil {
		mmGetSender.mock.t.Fatalf("ParcelMock.GetSender mock is already set by Set")
	}

	if mmGetSender.defaultExpectation == nil {
		mmGetSender.defaultExpectation = &ParcelMockGetSenderExpectation{mock: mmGetSender.mock}
	}
	mmGetSender.defaultExpectation.results = &ParcelMockGetSenderResults{r1}
	return mmGetSender.mock
}

//Set uses given function f to mock the Parcel.GetSender method
func (mmGetSender *mParcelMockGetSender) Set(f func() (r1 mm_insolar.Reference)) *ParcelMock {
	if mmGetSender.defaultExpectation != nil {
		mmGetSender.mock.t.Fatalf("Default expectation is already set for the Parcel.GetSender method")
	}

	if len(mmGetSender.expectations) > 0 {
		mmGetSender.mock.t.Fatalf("Some expectations are already set for the Parcel.GetSender method")
	}

	mmGetSender.mock.funcGetSender = f
	return mmGetSender.mock
}

// GetSender implements insolar.Parcel
func (mmGetSender *ParcelMock) GetSender() (r1 mm_insolar.Reference) {
	mm_atomic.AddUint64(&mmGetSender.beforeGetSenderCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSender.afterGetSenderCounter, 1)

	if mmGetSender.inspectFuncGetSender != nil {
		mmGetSender.inspectFuncGetSender()
	}

	if mmGetSender.GetSenderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSender.GetSenderMock.defaultExpectation.Counter, 1)

		results := mmGetSender.GetSenderMock.defaultExpectation.results
		if results == nil {
			mmGetSender.t.Fatal("No results are set for the ParcelMock.GetSender")
		}
		return (*results).r1
	}
	if mmGetSender.funcGetSender != nil {
		return mmGetSender.funcGetSender()
	}
	mmGetSender.t.Fatalf("Unexpected call to ParcelMock.GetSender.")
	return
}

// GetSenderAfterCounter returns a count of finished ParcelMock.GetSender invocations
func (mmGetSender *ParcelMock) GetSenderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSender.afterGetSenderCounter)
}

// GetSenderBeforeCounter returns a count of ParcelMock.GetSender invocations
func (mmGetSender *ParcelMock) GetSenderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSender.beforeGetSenderCounter)
}

// MinimockGetSenderDone returns true if the count of the GetSender invocations corresponds
// the number of defined expectations
func (m *ParcelMock) MinimockGetSenderDone() bool {
	for _, e := range m.GetSenderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSenderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSenderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSender != nil && mm_atomic.LoadUint64(&m.afterGetSenderCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetSenderInspect logs each unmet expectation
func (m *ParcelMock) MinimockGetSenderInspect() {
	for _, e := range m.GetSenderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ParcelMock.GetSender")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSenderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSenderCounter) < 1 {
		m.t.Error("Expected call to ParcelMock.GetSender")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSender != nil && mm_atomic.LoadUint64(&m.afterGetSenderCounter) < 1 {
		m.t.Error("Expected call to ParcelMock.GetSender")
	}
}

type mParcelMockGetSign struct {
	mock               *ParcelMock
	defaultExpectation *ParcelMockGetSignExpectation
	expectations       []*ParcelMockGetSignExpectation
}

// ParcelMockGetSignExpectation specifies expectation struct of the Parcel.GetSign
type ParcelMockGetSignExpectation struct {
	mock *ParcelMock

	results *ParcelMockGetSignResults
	Counter uint64
}

// ParcelMockGetSignResults contains results of the Parcel.GetSign
type ParcelMockGetSignResults struct {
	ba1 []byte
}

// Expect sets up expected params for Parcel.GetSign
func (mmGetSign *mParcelMockGetSign) Expect() *mParcelMockGetSign {
	if mmGetSign.mock.funcGetSign != nil {
		mmGetSign.mock.t.Fatalf("ParcelMock.GetSign mock is already set by Set")
	}

	if mmGetSign.defaultExpectation == nil {
		mmGetSign.defaultExpectation = &ParcelMockGetSignExpectation{}
	}

	return mmGetSign
}

// Inspect accepts an inspector function that has same arguments as the Parcel.GetSign
func (mmGetSign *mParcelMockGetSign) Inspect(f func()) *mParcelMockGetSign {
	if mmGetSign.mock.inspectFuncGetSign != nil {
		mmGetSign.mock.t.Fatalf("Inspect function is already set for ParcelMock.GetSign")
	}

	mmGetSign.mock.inspectFuncGetSign = f

	return mmGetSign
}

// Return sets up results that will be returned by Parcel.GetSign
func (mmGetSign *mParcelMockGetSign) Return(ba1 []byte) *ParcelMock {
	if mmGetSign.mock.funcGetSign != nil {
		mmGetSign.mock.t.Fatalf("ParcelMock.GetSign mock is already set by Set")
	}

	if mmGetSign.defaultExpectation == nil {
		mmGetSign.defaultExpectation = &ParcelMockGetSignExpectation{mock: mmGetSign.mock}
	}
	mmGetSign.defaultExpectation.results = &ParcelMockGetSignResults{ba1}
	return mmGetSign.mock
}

//Set uses given function f to mock the Parcel.GetSign method
func (mmGetSign *mParcelMockGetSign) Set(f func() (ba1 []byte)) *ParcelMock {
	if mmGetSign.defaultExpectation != nil {
		mmGetSign.mock.t.Fatalf("Default expectation is already set for the Parcel.GetSign method")
	}

	if len(mmGetSign.expectations) > 0 {
		mmGetSign.mock.t.Fatalf("Some expectations are already set for the Parcel.GetSign method")
	}

	mmGetSign.mock.funcGetSign = f
	return mmGetSign.mock
}

// GetSign implements insolar.Parcel
func (mmGetSign *ParcelMock) GetSign() (ba1 []byte) {
	mm_atomic.AddUint64(&mmGetSign.beforeGetSignCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSign.afterGetSignCounter, 1)

	if mmGetSign.inspectFuncGetSign != nil {
		mmGetSign.inspectFuncGetSign()
	}

	if mmGetSign.GetSignMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSign.GetSignMock.defaultExpectation.Counter, 1)

		results := mmGetSign.GetSignMock.defaultExpectation.results
		if results == nil {
			mmGetSign.t.Fatal("No results are set for the ParcelMock.GetSign")
		}
		return (*results).ba1
	}
	if mmGetSign.funcGetSign != nil {
		return mmGetSign.funcGetSign()
	}
	mmGetSign.t.Fatalf("Unexpected call to ParcelMock.GetSign.")
	return
}

// GetSignAfterCounter returns a count of finished ParcelMock.GetSign invocations
func (mmGetSign *ParcelMock) GetSignAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSign.afterGetSignCounter)
}

// GetSignBeforeCounter returns a count of ParcelMock.GetSign invocations
func (mmGetSign *ParcelMock) GetSignBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSign.beforeGetSignCounter)
}

// MinimockGetSignDone returns true if the count of the GetSign invocations corresponds
// the number of defined expectations
func (m *ParcelMock) MinimockGetSignDone() bool {
	for _, e := range m.GetSignMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSignMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSignCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSign != nil && mm_atomic.LoadUint64(&m.afterGetSignCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetSignInspect logs each unmet expectation
func (m *ParcelMock) MinimockGetSignInspect() {
	for _, e := range m.GetSignMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ParcelMock.GetSign")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSignMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSignCounter) < 1 {
		m.t.Error("Expected call to ParcelMock.GetSign")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSign != nil && mm_atomic.LoadUint64(&m.afterGetSignCounter) < 1 {
		m.t.Error("Expected call to ParcelMock.GetSign")
	}
}

type mParcelMockMessage struct {
	mock               *ParcelMock
	defaultExpectation *ParcelMockMessageExpectation
	expectations       []*ParcelMockMessageExpectation
}

// ParcelMockMessageExpectation specifies expectation struct of the Parcel.Message
type ParcelMockMessageExpectation struct {
	mock *ParcelMock

	results *ParcelMockMessageResults
	Counter uint64
}

// ParcelMockMessageResults contains results of the Parcel.Message
type ParcelMockMessageResults struct {
	m1 mm_insolar.Message
}

// Expect sets up expected params for Parcel.Message
func (mmMessage *mParcelMockMessage) Expect() *mParcelMockMessage {
	if mmMessage.mock.funcMessage != nil {
		mmMessage.mock.t.Fatalf("ParcelMock.Message mock is already set by Set")
	}

	if mmMessage.defaultExpectation == nil {
		mmMessage.defaultExpectation = &ParcelMockMessageExpectation{}
	}

	return mmMessage
}

// Inspect accepts an inspector function that has same arguments as the Parcel.Message
func (mmMessage *mParcelMockMessage) Inspect(f func()) *mParcelMockMessage {
	if mmMessage.mock.inspectFuncMessage != nil {
		mmMessage.mock.t.Fatalf("Inspect function is already set for ParcelMock.Message")
	}

	mmMessage.mock.inspectFuncMessage = f

	return mmMessage
}

// Return sets up results that will be returned by Parcel.Message
func (mmMessage *mParcelMockMessage) Return(m1 mm_insolar.Message) *ParcelMock {
	if mmMessage.mock.funcMessage != nil {
		mmMessage.mock.t.Fatalf("ParcelMock.Message mock is already set by Set")
	}

	if mmMessage.defaultExpectation == nil {
		mmMessage.defaultExpectation = &ParcelMockMessageExpectation{mock: mmMessage.mock}
	}
	mmMessage.defaultExpectation.results = &ParcelMockMessageResults{m1}
	return mmMessage.mock
}

//Set uses given function f to mock the Parcel.Message method
func (mmMessage *mParcelMockMessage) Set(f func() (m1 mm_insolar.Message)) *ParcelMock {
	if mmMessage.defaultExpectation != nil {
		mmMessage.mock.t.Fatalf("Default expectation is already set for the Parcel.Message method")
	}

	if len(mmMessage.expectations) > 0 {
		mmMessage.mock.t.Fatalf("Some expectations are already set for the Parcel.Message method")
	}

	mmMessage.mock.funcMessage = f
	return mmMessage.mock
}

// Message implements insolar.Parcel
func (mmMessage *ParcelMock) Message() (m1 mm_insolar.Message) {
	mm_atomic.AddUint64(&mmMessage.beforeMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmMessage.afterMessageCounter, 1)

	if mmMessage.inspectFuncMessage != nil {
		mmMessage.inspectFuncMessage()
	}

	if mmMessage.MessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMessage.MessageMock.defaultExpectation.Counter, 1)

		results := mmMessage.MessageMock.defaultExpectation.results
		if results == nil {
			mmMessage.t.Fatal("No results are set for the ParcelMock.Message")
		}
		return (*results).m1
	}
	if mmMessage.funcMessage != nil {
		return mmMessage.funcMessage()
	}
	mmMessage.t.Fatalf("Unexpected call to ParcelMock.Message.")
	return
}

// MessageAfterCounter returns a count of finished ParcelMock.Message invocations
func (mmMessage *ParcelMock) MessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMessage.afterMessageCounter)
}

// MessageBeforeCounter returns a count of ParcelMock.Message invocations
func (mmMessage *ParcelMock) MessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMessage.beforeMessageCounter)
}

// MinimockMessageDone returns true if the count of the Message invocations corresponds
// the number of defined expectations
func (m *ParcelMock) MinimockMessageDone() bool {
	for _, e := range m.MessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMessageCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMessage != nil && mm_atomic.LoadUint64(&m.afterMessageCounter) < 1 {
		return false
	}
	return true
}

// MinimockMessageInspect logs each unmet expectation
func (m *ParcelMock) MinimockMessageInspect() {
	for _, e := range m.MessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ParcelMock.Message")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMessageCounter) < 1 {
		m.t.Error("Expected call to ParcelMock.Message")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMessage != nil && mm_atomic.LoadUint64(&m.afterMessageCounter) < 1 {
		m.t.Error("Expected call to ParcelMock.Message")
	}
}

type mParcelMockPulse struct {
	mock               *ParcelMock
	defaultExpectation *ParcelMockPulseExpectation
	expectations       []*ParcelMockPulseExpectation
}

// ParcelMockPulseExpectation specifies expectation struct of the Parcel.Pulse
type ParcelMockPulseExpectation struct {
	mock *ParcelMock

	results *ParcelMockPulseResults
	Counter uint64
}

// ParcelMockPulseResults contains results of the Parcel.Pulse
type ParcelMockPulseResults struct {
	p1 mm_insolar.PulseNumber
}

// Expect sets up expected params for Parcel.Pulse
func (mmPulse *mParcelMockPulse) Expect() *mParcelMockPulse {
	if mmPulse.mock.funcPulse != nil {
		mmPulse.mock.t.Fatalf("ParcelMock.Pulse mock is already set by Set")
	}

	if mmPulse.defaultExpectation == nil {
		mmPulse.defaultExpectation = &ParcelMockPulseExpectation{}
	}

	return mmPulse
}

// Inspect accepts an inspector function that has same arguments as the Parcel.Pulse
func (mmPulse *mParcelMockPulse) Inspect(f func()) *mParcelMockPulse {
	if mmPulse.mock.inspectFuncPulse != nil {
		mmPulse.mock.t.Fatalf("Inspect function is already set for ParcelMock.Pulse")
	}

	mmPulse.mock.inspectFuncPulse = f

	return mmPulse
}

// Return sets up results that will be returned by Parcel.Pulse
func (mmPulse *mParcelMockPulse) Return(p1 mm_insolar.PulseNumber) *ParcelMock {
	if mmPulse.mock.funcPulse != nil {
		mmPulse.mock.t.Fatalf("ParcelMock.Pulse mock is already set by Set")
	}

	if mmPulse.defaultExpectation == nil {
		mmPulse.defaultExpectation = &ParcelMockPulseExpectation{mock: mmPulse.mock}
	}
	mmPulse.defaultExpectation.results = &ParcelMockPulseResults{p1}
	return mmPulse.mock
}

//Set uses given function f to mock the Parcel.Pulse method
func (mmPulse *mParcelMockPulse) Set(f func() (p1 mm_insolar.PulseNumber)) *ParcelMock {
	if mmPulse.defaultExpectation != nil {
		mmPulse.mock.t.Fatalf("Default expectation is already set for the Parcel.Pulse method")
	}

	if len(mmPulse.expectations) > 0 {
		mmPulse.mock.t.Fatalf("Some expectations are already set for the Parcel.Pulse method")
	}

	mmPulse.mock.funcPulse = f
	return mmPulse.mock
}

// Pulse implements insolar.Parcel
func (mmPulse *ParcelMock) Pulse() (p1 mm_insolar.PulseNumber) {
	mm_atomic.AddUint64(&mmPulse.beforePulseCounter, 1)
	defer mm_atomic.AddUint64(&mmPulse.afterPulseCounter, 1)

	if mmPulse.inspectFuncPulse != nil {
		mmPulse.inspectFuncPulse()
	}

	if mmPulse.PulseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPulse.PulseMock.defaultExpectation.Counter, 1)

		results := mmPulse.PulseMock.defaultExpectation.results
		if results == nil {
			mmPulse.t.Fatal("No results are set for the ParcelMock.Pulse")
		}
		return (*results).p1
	}
	if mmPulse.funcPulse != nil {
		return mmPulse.funcPulse()
	}
	mmPulse.t.Fatalf("Unexpected call to ParcelMock.Pulse.")
	return
}

// PulseAfterCounter returns a count of finished ParcelMock.Pulse invocations
func (mmPulse *ParcelMock) PulseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPulse.afterPulseCounter)
}

// PulseBeforeCounter returns a count of ParcelMock.Pulse invocations
func (mmPulse *ParcelMock) PulseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPulse.beforePulseCounter)
}

// MinimockPulseDone returns true if the count of the Pulse invocations corresponds
// the number of defined expectations
func (m *ParcelMock) MinimockPulseDone() bool {
	for _, e := range m.PulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPulseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPulse != nil && mm_atomic.LoadUint64(&m.afterPulseCounter) < 1 {
		return false
	}
	return true
}

// MinimockPulseInspect logs each unmet expectation
func (m *ParcelMock) MinimockPulseInspect() {
	for _, e := range m.PulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ParcelMock.Pulse")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPulseCounter) < 1 {
		m.t.Error("Expected call to ParcelMock.Pulse")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPulse != nil && mm_atomic.LoadUint64(&m.afterPulseCounter) < 1 {
		m.t.Error("Expected call to ParcelMock.Pulse")
	}
}

type mParcelMockSetSender struct {
	mock               *ParcelMock
	defaultExpectation *ParcelMockSetSenderExpectation
	expectations       []*ParcelMockSetSenderExpectation

	callArgs []*ParcelMockSetSenderParams
	mutex    sync.RWMutex
}

// ParcelMockSetSenderExpectation specifies expectation struct of the Parcel.SetSender
type ParcelMockSetSenderExpectation struct {
	mock   *ParcelMock
	params *ParcelMockSetSenderParams

	Counter uint64
}

// ParcelMockSetSenderParams contains parameters of the Parcel.SetSender
type ParcelMockSetSenderParams struct {
	r1 mm_insolar.Reference
}

// Expect sets up expected params for Parcel.SetSender
func (mmSetSender *mParcelMockSetSender) Expect(r1 mm_insolar.Reference) *mParcelMockSetSender {
	if mmSetSender.mock.funcSetSender != nil {
		mmSetSender.mock.t.Fatalf("ParcelMock.SetSender mock is already set by Set")
	}

	if mmSetSender.defaultExpectation == nil {
		mmSetSender.defaultExpectation = &ParcelMockSetSenderExpectation{}
	}

	mmSetSender.defaultExpectation.params = &ParcelMockSetSenderParams{r1}
	for _, e := range mmSetSender.expectations {
		if minimock.Equal(e.params, mmSetSender.defaultExpectation.params) {
			mmSetSender.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetSender.defaultExpectation.params)
		}
	}

	return mmSetSender
}

// Inspect accepts an inspector function that has same arguments as the Parcel.SetSender
func (mmSetSender *mParcelMockSetSender) Inspect(f func(r1 mm_insolar.Reference)) *mParcelMockSetSender {
	if mmSetSender.mock.inspectFuncSetSender != nil {
		mmSetSender.mock.t.Fatalf("Inspect function is already set for ParcelMock.SetSender")
	}

	mmSetSender.mock.inspectFuncSetSender = f

	return mmSetSender
}

// Return sets up results that will be returned by Parcel.SetSender
func (mmSetSender *mParcelMockSetSender) Return() *ParcelMock {
	if mmSetSender.mock.funcSetSender != nil {
		mmSetSender.mock.t.Fatalf("ParcelMock.SetSender mock is already set by Set")
	}

	if mmSetSender.defaultExpectation == nil {
		mmSetSender.defaultExpectation = &ParcelMockSetSenderExpectation{mock: mmSetSender.mock}
	}

	return mmSetSender.mock
}

//Set uses given function f to mock the Parcel.SetSender method
func (mmSetSender *mParcelMockSetSender) Set(f func(r1 mm_insolar.Reference)) *ParcelMock {
	if mmSetSender.defaultExpectation != nil {
		mmSetSender.mock.t.Fatalf("Default expectation is already set for the Parcel.SetSender method")
	}

	if len(mmSetSender.expectations) > 0 {
		mmSetSender.mock.t.Fatalf("Some expectations are already set for the Parcel.SetSender method")
	}

	mmSetSender.mock.funcSetSender = f
	return mmSetSender.mock
}

// SetSender implements insolar.Parcel
func (mmSetSender *ParcelMock) SetSender(r1 mm_insolar.Reference) {
	mm_atomic.AddUint64(&mmSetSender.beforeSetSenderCounter, 1)
	defer mm_atomic.AddUint64(&mmSetSender.afterSetSenderCounter, 1)

	if mmSetSender.inspectFuncSetSender != nil {
		mmSetSender.inspectFuncSetSender(r1)
	}

	params := &ParcelMockSetSenderParams{r1}

	// Record call args
	mmSetSender.SetSenderMock.mutex.Lock()
	mmSetSender.SetSenderMock.callArgs = append(mmSetSender.SetSenderMock.callArgs, params)
	mmSetSender.SetSenderMock.mutex.Unlock()

	for _, e := range mmSetSender.SetSenderMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetSender.SetSenderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetSender.SetSenderMock.defaultExpectation.Counter, 1)
		want := mmSetSender.SetSenderMock.defaultExpectation.params
		got := ParcelMockSetSenderParams{r1}
		if want != nil && !minimock.Equal(*want, got) {
			mmSetSender.t.Errorf("ParcelMock.SetSender got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmSetSender.funcSetSender != nil {
		mmSetSender.funcSetSender(r1)
		return
	}
	mmSetSender.t.Fatalf("Unexpected call to ParcelMock.SetSender. %v", r1)

}

// SetSenderAfterCounter returns a count of finished ParcelMock.SetSender invocations
func (mmSetSender *ParcelMock) SetSenderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetSender.afterSetSenderCounter)
}

// SetSenderBeforeCounter returns a count of ParcelMock.SetSender invocations
func (mmSetSender *ParcelMock) SetSenderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetSender.beforeSetSenderCounter)
}

// Calls returns a list of arguments used in each call to ParcelMock.SetSender.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetSender *mParcelMockSetSender) Calls() []*ParcelMockSetSenderParams {
	mmSetSender.mutex.RLock()

	argCopy := make([]*ParcelMockSetSenderParams, len(mmSetSender.callArgs))
	copy(argCopy, mmSetSender.callArgs)

	mmSetSender.mutex.RUnlock()

	return argCopy
}

// MinimockSetSenderDone returns true if the count of the SetSender invocations corresponds
// the number of defined expectations
func (m *ParcelMock) MinimockSetSenderDone() bool {
	for _, e := range m.SetSenderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetSenderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetSenderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetSender != nil && mm_atomic.LoadUint64(&m.afterSetSenderCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetSenderInspect logs each unmet expectation
func (m *ParcelMock) MinimockSetSenderInspect() {
	for _, e := range m.SetSenderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ParcelMock.SetSender with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetSenderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetSenderCounter) < 1 {
		if m.SetSenderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ParcelMock.SetSender")
		} else {
			m.t.Errorf("Expected call to ParcelMock.SetSender with params: %#v", *m.SetSenderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetSender != nil && mm_atomic.LoadUint64(&m.afterSetSenderCounter) < 1 {
		m.t.Error("Expected call to ParcelMock.SetSender")
	}
}

type mParcelMockType struct {
	mock               *ParcelMock
	defaultExpectation *ParcelMockTypeExpectation
	expectations       []*ParcelMockTypeExpectation
}

// ParcelMockTypeExpectation specifies expectation struct of the Parcel.Type
type ParcelMockTypeExpectation struct {
	mock *ParcelMock

	results *ParcelMockTypeResults
	Counter uint64
}

// ParcelMockTypeResults contains results of the Parcel.Type
type ParcelMockTypeResults struct {
	m1 mm_insolar.MessageType
}

// Expect sets up expected params for Parcel.Type
func (mmType *mParcelMockType) Expect() *mParcelMockType {
	if mmType.mock.funcType != nil {
		mmType.mock.t.Fatalf("ParcelMock.Type mock is already set by Set")
	}

	if mmType.defaultExpectation == nil {
		mmType.defaultExpectation = &ParcelMockTypeExpectation{}
	}

	return mmType
}

// Inspect accepts an inspector function that has same arguments as the Parcel.Type
func (mmType *mParcelMockType) Inspect(f func()) *mParcelMockType {
	if mmType.mock.inspectFuncType != nil {
		mmType.mock.t.Fatalf("Inspect function is already set for ParcelMock.Type")
	}

	mmType.mock.inspectFuncType = f

	return mmType
}

// Return sets up results that will be returned by Parcel.Type
func (mmType *mParcelMockType) Return(m1 mm_insolar.MessageType) *ParcelMock {
	if mmType.mock.funcType != nil {
		mmType.mock.t.Fatalf("ParcelMock.Type mock is already set by Set")
	}

	if mmType.defaultExpectation == nil {
		mmType.defaultExpectation = &ParcelMockTypeExpectation{mock: mmType.mock}
	}
	mmType.defaultExpectation.results = &ParcelMockTypeResults{m1}
	return mmType.mock
}

//Set uses given function f to mock the Parcel.Type method
func (mmType *mParcelMockType) Set(f func() (m1 mm_insolar.MessageType)) *ParcelMock {
	if mmType.defaultExpectation != nil {
		mmType.mock.t.Fatalf("Default expectation is already set for the Parcel.Type method")
	}

	if len(mmType.expectations) > 0 {
		mmType.mock.t.Fatalf("Some expectations are already set for the Parcel.Type method")
	}

	mmType.mock.funcType = f
	return mmType.mock
}

// Type implements insolar.Parcel
func (mmType *ParcelMock) Type() (m1 mm_insolar.MessageType) {
	mm_atomic.AddUint64(&mmType.beforeTypeCounter, 1)
	defer mm_atomic.AddUint64(&mmType.afterTypeCounter, 1)

	if mmType.inspectFuncType != nil {
		mmType.inspectFuncType()
	}

	if mmType.TypeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmType.TypeMock.defaultExpectation.Counter, 1)

		results := mmType.TypeMock.defaultExpectation.results
		if results == nil {
			mmType.t.Fatal("No results are set for the ParcelMock.Type")
		}
		return (*results).m1
	}
	if mmType.funcType != nil {
		return mmType.funcType()
	}
	mmType.t.Fatalf("Unexpected call to ParcelMock.Type.")
	return
}

// TypeAfterCounter returns a count of finished ParcelMock.Type invocations
func (mmType *ParcelMock) TypeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmType.afterTypeCounter)
}

// TypeBeforeCounter returns a count of ParcelMock.Type invocations
func (mmType *ParcelMock) TypeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmType.beforeTypeCounter)
}

// MinimockTypeDone returns true if the count of the Type invocations corresponds
// the number of defined expectations
func (m *ParcelMock) MinimockTypeDone() bool {
	for _, e := range m.TypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TypeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTypeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcType != nil && mm_atomic.LoadUint64(&m.afterTypeCounter) < 1 {
		return false
	}
	return true
}

// MinimockTypeInspect logs each unmet expectation
func (m *ParcelMock) MinimockTypeInspect() {
	for _, e := range m.TypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ParcelMock.Type")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TypeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTypeCounter) < 1 {
		m.t.Error("Expected call to ParcelMock.Type")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcType != nil && mm_atomic.LoadUint64(&m.afterTypeCounter) < 1 {
		m.t.Error("Expected call to ParcelMock.Type")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ParcelMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAllowedSenderObjectAndRoleInspect()

		m.MinimockContextInspect()

		m.MinimockDefaultRoleInspect()

		m.MinimockDefaultTargetInspect()

		m.MinimockGetCallerInspect()

		m.MinimockGetSenderInspect()

		m.MinimockGetSignInspect()

		m.MinimockMessageInspect()

		m.MinimockPulseInspect()

		m.MinimockSetSenderInspect()

		m.MinimockTypeInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ParcelMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ParcelMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAllowedSenderObjectAndRoleDone() &&
		m.MinimockContextDone() &&
		m.MinimockDefaultRoleDone() &&
		m.MinimockDefaultTargetDone() &&
		m.MinimockGetCallerDone() &&
		m.MinimockGetSenderDone() &&
		m.MinimockGetSignDone() &&
		m.MinimockMessageDone() &&
		m.MinimockPulseDone() &&
		m.MinimockSetSenderDone() &&
		m.MinimockTypeDone()
}
